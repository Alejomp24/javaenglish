package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Files.list(Paths.get(".")).forEach(System.out::println);
	}
}

Resultado:

.\.classpath
.\.project
.\.settings
.\bin
.\resources
.\src

Files.walk = Permite ver la profundidad(camino, ruta) de los archivos.

Otra forma de hacerlo:
package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.function.BiPredicate;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path currentDirectory = Paths.get(".");
		BiPredicate<Path, BasicFileAttributes> directoryMatcher = (path, attributes) -> attributes.isDirectory();
		Files.find(currentDirectory, 1, directoryMatcher).forEach(System.out::println);
	}
}

FILTRAR UNICAMENTE LOS ARCHIVOS CON EXTENSIÓN JAVA.

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.function.Predicate;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path currentDirectory = Paths.get(".");
		Predicate<? super Path> predicate = path -> String.valueOf(path).contains(".java");
		Files.walk(currentDirectory, 4).filter(predicate).forEach(System.out::println);
	}
}

Resultado: .\src\com\perezcasallas\DirectoryScanRunner.java

Otra forma de hacerlo:

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.function.BiPredicate;

public class DirectoryScanRunner {
	public static void main(String[] args) throws IOException {
		Path currentDirectory = Paths.get(".");
		BiPredicate<Path, BasicFileAttributes> matcher = (path, attributes) -> String.valueOf(path).contains(".java");
		Files.find(currentDirectory, 4, matcher).forEach(System.out::println);
	}
}

LEER UN ARCHIVO CON EXTENSIÓN .TXT

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path pathFileToRead = Paths.get("./resources/data.txt");
		List<String> lines = Files.readAllLines(pathFileToRead);
		System.out.println(lines);
	}
}

Otra forma de hacerlo:

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path pathFileToRead = Paths.get("./resources/data.txt");
		Files.lines(pathFileToRead).forEach(System.out::println);
	}
}

COVERTIR CONTENIDO DE UN ARCHIVO A MINÚSCULA:

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path pathFileToRead = Paths.get("./resources/data.txt");
		// List<String> lines = Files.readAllLines(pathFileToRead);
		// System.out.println(lines);
		Files.lines(pathFileToRead).map(String::toLowerCase).forEach(System.out::println);
	}
}

VALIDAR QUE EL ARCHIVO CONTENGA ALGO EN ESPECÍFICO

package com.perezcasallas;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class DirectoryScanRunner {

	public static void main(String[] args) throws IOException {
		Path pathFileToRead = Paths.get("./resources/data.txt");
		// List<String> lines = Files.readAllLines(pathFileToRead);
		// System.out.println(lines);
		Files.lines(pathFileToRead).map(String::toLowerCase).filter(str -> str.contains("a"))
				.forEach(System.out::println);
	}
}

DEFINICIONES.

Path Class: Representa la ruta del archivo o directorio

Paths.get(): Método para crear un objeto Path

Predicate: Interfaz funcional que devuelve booleano con un argumento.

BiPredicate: Interfaz funcional que devuelve booleano con dos argumentos.

Files Class: Proporciona métodos de utilidad para operaciones de archivos y directorios.

Files.createDirectory(): Crea un nuevo directorio

Files.delete(): Elimina un archivo o directorio

Files.copy(): Copia un archivo o directorio de una ubicación a otra

Files.move(): Mueve un archivo o directorio de una ubicación a otra

Files.exists(): Comprueba si existe un archivo o directorio

Files.find(): Busca recursivamente archivos y directorios.

Files.lines(): Lee el archivo como un flujo de líneas

Files.write(): Escribe bytes en un archivo en Java



