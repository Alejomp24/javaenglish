MODIFICADORES.

afectan clases, variables y metodos.

MODIFICADORES DE ACCESO.


public				- Se puede usar desde cualquier lugar, es decir, desde cualquier paquete o subpaquete y en consecuencia desde cualquier proyecto.
(default)			- Si no se especifica si es private, public o protected; solo se puede usar en el paquete y en la misma clase.

public & (default)	- Estos son los únicos modificadores de acceso sobre las clases. 

private				- Solo se pueden usar dentro de la clase donde fue creado, es decir, no se puede usar en ningún otro lugar.
protected			- Solo se puede usar en el mismo paquete o en subclases, es decir, una clase extiende otra.

private & protected - No se pueden usar en las clases.

1.Dentro de la misma clases puedo usar los diferentes modificadores.
2.Dentro del mismo paquete pero en diferente(s) clase(s) no se puede usar algo private de otra clase.
3.En otro paquete solo se puede usar algo public de otro paquete

Ayudan a decidir qué tipo de cosas en la clase son accesibles para las personas que escriben código fuera de tu clase.


MODIFICADORES DE NO ACCESO.

final				- Quiere decir que una clase no se puede extender más, nadie puede heredar de esa clase especifica.
					- En terminos de variables, al colocar final indica que la variable no puede tener otro valor, solo puede tomar un valor.
						
static				- Entiendo es cuando una variable es compartida por varias instancias(objetos)
					- Un metodo estático, no puede tener acceso a un valor no estático. Es decir, los metodos estáticos solo pueden hacer referencia a variables estáticas y solo llamar a metodos estáticos.
					- Un metodo no estático, si puede tener acceso a un valor estático.
					
					
NESTED CLASSES (CLASES ANIDADAS)

Es decir una o varias clases que están anidadas a otra clase.

INNER CLASSES (CLASE INTERNA) 
No permite crear instancias fuera de la clase interna, pero para crear la instancia se necesitaría una instancia de la clase que la incluye.
La cuestion de una instancia de una clase interna no puede existir sin una instancia de la clase principal.
La clase interna puede usar las variables de la clase principal. 


STATIC NESTED CLASSES (CLASES ANIDADAS ESTÁTICAS)
Permite crear instancias fuera de la clase estática.
La clase anidada estática no puede usar las variables de la clase principal o mejor dicho a variables no estáticas. 

package com.perezcasallas;

class DefaultClass{
	
}

public class NestedClassRunner {
	
	int i;
	static int j = 12;
	
	class InnerClass{
		public void method() {
			i = 5;
		}
	}
	
	static class StaticNestedClass{
		
	}

	public static void main(String[] args) {
		StaticNestedClass staticNestedClass = new StaticNestedClass();
		
		NestedClassRunner nestedClassRunner = new NestedClassRunner();
		InnerClass innerClass = nestedClassRunner.new InnerClass();		
	}
}


CLASES ANONIMAS

Son aquellas clases que están integradas dentro del código del programa y no tienen definido un nombre, un ejemplo de ello son las expresiones lambda.
Se crean cuando cuando solo se va a ejecutar una vez un metodo que podría ir en un clase y que no se va a reutilizar en ningún otro lugar.


package com.perezcasallas;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class AnonymousClassRunner {

	public static void main(String[] args) {
		List<String> animals = new ArrayList<String>(List.of("Hamster", "Ant", "Cat", "Ball", "Elephant"));
		//Clase Anonima
		Collections.sort(animals, new Comparator<String>() {
			@Override
			public int compare(String str1, String str2) {
				return Integer.compare(str1.length(), str2.length());
			}
		});
		//Clase Anonima
		System.out.println(animals);
	}
}


ENUM

Las enumeraciones ayudan a restringir el tipo de valores que están presentes a un conjunto restringido.

Ejemplos:
-DayOfWeek
-Month

Es como parecido a los utilitarios.

enum Season {
	SUMMER(1), WINTER(2), FALL(3), SPRING(4);

	private int value;

	private Season(int value) {
		this.value = value;
	}

	public int getValue() {
		return value;
	}

}

public enum Direction {
    NORTH("North"),
    SOUTH("South"),
    EAST("East"),
    WEST("West");

    private String name;

    Direction(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public Direction left() {
        // You are to implement the logic that correctly gets the Direction on the "left"
        // If we represent the directions in a circular format going clockwise
        // then the direction to the "left" of NORTH is WEST, of WEST is SOUTH, of SOUTH is EAST, and of EAST is NORTH
        switch (this) {
            case NORTH:
                return WEST;
            case WEST:
                return SOUTH;
            case SOUTH:
                return EAST;
            case EAST:
                return NORTH;
        }
        return this;
    }

    public Direction right() {
        // Similarly, you are to implement the logic that correctly gets the Direction on the "right"
        // If we represent the directions in a circular format going clockwise
        // then the direction to the "right" of NORTH is EAST, of EAST is SOUTH, of SOUTH is WEST, and of WEST is NORTH
        switch (this) {
            case NORTH:
                return EAST;
            case EAST:
                return SOUTH;
            case SOUTH:
                return WEST;
            case WEST:
                return NORTH;
        }
        return this;
    }
}
